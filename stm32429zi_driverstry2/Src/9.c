/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include "stm32f429zi.h"
#include <stdint.h>
#include <string.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
void	delay(void){
	for(uint32_t i=0;i<500000/2;i++);
}
SPI_Handle_t SPI2Handle;
#define MAX_LEN 500
volatile	uint8_t dataAvailable=0,rcvStop=0;
volatile char ReadByte;
volatile char RcvBuff[MAX_LEN];

#define 	BTN_PRESSED	HIGH
#define		LED_ON		1
#define		LED_OFF			0
#define	COMMAND_LED_CTRL	0X50
#define	COMMAND_SENSOR_READ	0X51
#define	COMMAND_LED_READ	0X52
#define	COMMAND_PRINT	0X53
#define	COMMAND_ID_READ	0X54
//arduino analog pins
#define ANALOG_PIN0	0
#define ANALOG_PIN1	1
#define ANALOG_PIN2	2
#define ANALOG_PIN3	3
#define ANALOG_PIN4	4

//ARDUINO LED
#define LED_PIN	9
/*
 * PB14->SPI2_MISO
 * PB15->SPI2_MOSI
 * PB13->SPI2_SCLK
 * PB12->SPI2_NSS
 * ALT FUNCTION MODE: 5
 */
void GPIO_ButtonInit(void){
	GPIO_Handle_t	GpioBtn;
	GpioBtn.pGPIOx=GPIOA;
			GpioBtn.GPIO_PinConfig.GPIO_PinNumber	=GPIO_PIN_NO_0;
			GpioBtn.GPIO_PinConfig.GPIO_PinMode		=GPIO_MODE_IN;
			GpioBtn.GPIO_PinConfig.GPIO_PinSpeed	=GPIO_SPEED_FAST;
			GpioBtn.GPIO_PinConfig.GPIO_PinPuPdControl=GPIO_PIN_NO_PUPD;

			GPIO_Init(&GpioBtn);
}
void Slave_GPIO_InterruptPinInit(void){
	GPIO_Handle_t spiIntPin;
	memset(&spiIntPin,0,sizeof(spiIntPin));
	//led gpio config
	spiIntPin.pGPIOx=GPIOD;
	spiIntPin.GPIO_PinConfig.GPIO_PinMode=GPIO_MODE_IT_FT;
	spiIntPin.GPIO_PinConfig.GPIO_PinPuPdControl=GPIO_PIN_NO_PUPD;
	spiIntPin.GPIO_PinConfig.GPIO_PinSpeed=GPIO_SPEED_LOW;

	spiIntPin.GPIO_PinConfig.GPIO_PinNumber=GPIO_PIN_NO_6;
	GPIO_Init(&spiIntPin);
	GPIO_IRQPriorityConfig(IRQ_NO_EXTI9_5, NVIC_IRQ_PRI15);
	GPIO_IRQConfig(IRQ_NO_EXTI9_5, ENABLE);
}
void SPI_GPIOInits(void){
	GPIO_Handle_t SPIPins;
	SPIPins.pGPIOx=GPIOB;
	SPIPins.GPIO_PinConfig.GPIO_PinMode=GPIO_MODE_ALTFN;
	SPIPins.GPIO_PinConfig.GPIO_PinAltFunMode=5;
	SPIPins.GPIO_PinConfig.GPIO_PinOPType=GPIO_OP_TYPE_PP;
	SPIPins.GPIO_PinConfig.GPIO_PinPuPdControl=GPIO_PIN_NO_PUPD;
	SPIPins.GPIO_PinConfig.GPIO_PinSpeed=GPIO_SPEED_FAST;
	//SCLK
	SPIPins.GPIO_PinConfig.GPIO_PinNumber=GPIO_PIN_NO_13;
	GPIO_Init(&SPIPins);
	//MOSI
		SPIPins.GPIO_PinConfig.GPIO_PinNumber=GPIO_PIN_NO_15;
		GPIO_Init(&SPIPins);
		//NSS
			SPIPins.GPIO_PinConfig.GPIO_PinNumber=GPIO_PIN_NO_12;
			GPIO_Init(&SPIPins);
			//MISO
				SPIPins.GPIO_PinConfig.GPIO_PinNumber=GPIO_PIN_NO_14;
				GPIO_Init(&SPIPins);

}
void SPI2_Inits(){
	SPI_Handle_t	SPI2handle;
	SPI2handle.pSPIx=SPI2;
	SPI2handle.SPIConfig.SPI_BusConfig=SPI_BUS_CONFIG_FD;
	SPI2handle.SPIConfig.SPI_DeviceMode=SPI_DEVICE_MODE_MASTER;
	SPI2handle.SPIConfig.SPI_SclkSpeed=SPI_SCLK_SPEED_DIV8;
	SPI2handle.SPIConfig.SPI_DFF=SPI_DFF_8BITS;
	SPI2handle.SPIConfig.SPI_CPOL=SPI_CPOL_LOW;
	SPI2handle.SPIConfig.SPI_CPHA=SPI_CPHA_LOW;
	SPI2handle.SPIConfig.SPI_SSM=SPI_SSM_DI;//HW SLAVE MANAGEMENT ENABLE
	SPI_Init(&SPI2handle);
}
uint8_t SPI_VerifyResponse(uint8_t ackbyte){
	if(ackbyte==0xF5){
		//ack
		return 1;
	}
	return 0;
}
extern void initialise_monitor_handles(void);
int main(void)
{
	initialise_monitor_handles();
	printf("application is running\n");
	uint8_t	dummy_write=0xff;
	Slave_GPIO_InterruptPinInit();
	SPI_GPIOInits();
		SPI2_Inits();
		SPI_SSOEConfig(SPI2, ENABLE);





	while(1){
		rcvStop=0;
		//wait till data available interrupt from tx device(slave)
		while(!dataAvailable);
		GPIO_IRQConfig(IRQ_NO_EXTI9_5, DISABLE);
		SPI_PeripheralControl(SPI2, ENABLE);
		while(!rcvStop){
			//fetch the data from the spi peri byte by byte in interrupt mode
			while(SPI_SendDataIT(&SPI2Handle, &dummy_write,1)==SPI_BUSY_IN_TX);
			while(SPI_ReceiveDataIT(&SPI2Handle, &ReadByte,1)==SPI_BUSY_IN_RX);

		}
		//confirm spi not busy
		while(SPI_GetFlagStatus(SPI2, SPI_SR_BSY));
		//DISABLE SPI2 PERI
		SPI_PeripheralControl(SPI2, DISABLE);
		printf("Rcvd data = %s\n",RcvBuff);
		dataAvailable=0;
		GPIO_IRQConfig(IRQ_NO_EXTI9_5, ENABLE);
	}
	return 0;
}

void SPI2_IRQHandler(void){
	SPI_IRQHandling(&SPI2Handle);
}
void SPI_ApplicationEventCallBack(SPI_Handle_t *pSPIHandle,uint8_t AppEv){
	static uint32_t i=0;

	if(AppEv=SPI_EVENT_RX_CMPLT){
		RcvBuff[i++] =ReadByte;
		if(ReadByte== '\0' || (i==MAX_LEN)){
			rcvStop=1;
			RcvBuff[i-1]='\0';
			i=0;
		}
	}
}
void EXTI9_5_IRQHandler(void){
	GPIO_IRQHandling(GPIO_PIN_NO_6);
	dataAvailable=1;
}
